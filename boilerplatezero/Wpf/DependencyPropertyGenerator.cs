// Copyright © Ian Good

using Bpz.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Bpz.Wpf;

/// <summary>
/// Represents a source generator that produces idiomatic code for WPF dependency properties.
/// 
/// <para>Looks for things like<br/>
/// <c>public static readonly DependencyProperty FooProperty = Gen.Foo(123);</c><br/>
/// and generates the appropriate registration and getter/setter code.</para>
/// 
/// Property-changed handlers with appropriate names and compatible signatures like<br/>
/// <c>private static void FooPropertyChanged(MyClass self, DependencyPropertyChangedEventArgs e) { ... }</c><br/>
/// will be included in the registration.
/// </summary>
[Generator(LanguageNames.CSharp)]
public partial class DependencyPropertyGenerator : ISourceGenerator
{
	/// <summary>
	/// Whether the generated code should be null-aware (i.e. the nullable annotation context is enabled).
	/// </summary>
	private bool useNullableContext;

	// These will be initialized before first use.
	private INamedTypeSymbol objTypeSymbol = null!; // System.Object
	private INamedTypeSymbol doTypeSymbol = null!;  // System.Windows.DependencyObject
	private INamedTypeSymbol argsTypeSymbol = null!;// System.Windows.DependencyPropertyChangedEventArgs
	private INamedTypeSymbol? flagsTypeSymbol;      // System.Windows.FrameworkPropertyMetadataOptions
	private INamedTypeSymbol? reTypeSymbol;         // System.Windows.RoutedEvent

	public void Initialize(GeneratorInitializationContext context)
	{
		//DebugMe.Go();
		context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
	}

	public void Execute(GeneratorExecutionContext context)
	{
		//DebugMe.Go();

		this.useNullableContext = (context.ParseOptions as CSharpParseOptions)?.LanguageVersion >= LanguageVersion.CSharp8;

		var syntaxReceiver = (SyntaxReceiver)context.SyntaxReceiver!;

		// Cast keys to `ISymbol` in the key selector to make the analyzer shutup about CS8602 ("Dereference of a possibly null reference.").
		var namespaces = UpdateAndFilterGenerationRequests(context, syntaxReceiver.GenerationRequests)
		   .GroupBy(g => (ISymbol)g.FieldSymbol.ContainingType, SymbolEqualityComparer.Default)
		   .GroupBy(g => (ISymbol)g.Key.ContainingNamespace, SymbolEqualityComparer.Default);

		StringBuilder sourceBuilder = new();

		foreach (var namespaceGroup in namespaces)
		{
			// Get these type symbols now so we don't waste time finding them each time we need them later.
			this.objTypeSymbol ??= context.Compilation.GetTypeByMetadataName("System.Object")!;
			this.doTypeSymbol ??= context.Compilation.GetTypeByMetadataName("System.Windows.DependencyObject")!;
			this.argsTypeSymbol ??= context.Compilation.GetTypeByMetadataName("System.Windows.DependencyPropertyChangedEventArgs")!;
			this.flagsTypeSymbol ??= context.Compilation.GetTypeByMetadataName("System.Windows.FrameworkPropertyMetadataOptions");
			this.reTypeSymbol ??= context.Compilation.GetTypeByMetadataName("System.Windows.RoutedEvent");

			string namespaceName = namespaceGroup.Key.ToString();
			sourceBuilder.Append($@"
namespace {namespaceName}
{{");

			foreach (var classGroup in namespaceGroup)
			{
				string? maybeStatic = classGroup.Key.IsStatic ? "static " : null;
				string className = GeneratorOps.GetTypeName((INamedTypeSymbol)classGroup.Key);
				sourceBuilder.Append($@"
	{maybeStatic}partial class {className}
	{{");

				foreach (var generateThis in classGroup)
				{
					context.CancellationToken.ThrowIfCancellationRequested();

					this.ApppendSource(context, sourceBuilder, generateThis);
				}

				sourceBuilder.Append(@"
	}
");
			}

			sourceBuilder.Append(@"
}
");
		}

		if (sourceBuilder.Length != 0)
		{
			string? maybeNullableContext = this.useNullableContext ? "#nullable enable" : null;

			sourceBuilder.Insert(0,
$@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a boilerplatezero (BPZ) source generator.
//     Generator = {this.GetType().FullName}
//     {Diagnostics.HelpLinkUri}
// </auto-generated>
//------------------------------------------------------------------------------
{maybeNullableContext}
using System.Windows;
");

			context.AddSource($"bpz.DependencyProperties.g.cs", sourceBuilder.ToString());
		}
	}

	private class SyntaxReceiver : ISyntaxReceiver
	{
		public List<GenerationDetails> GenerationRequests { get; } = new();

		public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
		{
			// Looking for things like...
			//	public static readonly System.Windows.DependencyProperty FooProperty = Gen.Foo(123);
			//	public static readonly System.Windows.DependencyProperty BarProperty = GenAttached.Bar(123);
			if (syntaxNode is FieldDeclarationSyntax fieldDecl)
			{
				// Looking for "DependencyProperty" or "DependencyPropertyKey" as the type of the field...
				string fieldTypeName = fieldDecl.Declaration.Type.ToString();
				if (fieldTypeName.LastIndexOf("DependencyProperty", StringComparison.Ordinal) >= 0)
				{
					// Looking for field initialization like "= Gen.Foo"...
					var varDecl = fieldDecl.Declaration.Variables.FirstOrDefault();
					if (varDecl?.Initializer?.Value is InvocationExpressionSyntax invocationExpr &&
						invocationExpr.Expression is MemberAccessExpressionSyntax memberAccessExpr &&
						memberAccessExpr.Expression is SimpleNameSyntax idName)
					{
						if (idName.Identifier.ValueText == "Gen")
						{
							this.GenerationRequests.Add(new(memberAccessExpr.Name, false));
						}
						else if (idName.Identifier.ValueText == "GenAttached")
						{
							this.GenerationRequests.Add(new(memberAccessExpr.Name, true));
						}
					}
				}
			}
		}
	}
}
